<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274061; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2231"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
1. SVM算法特性：
<div><img src="5.2 支持向量机(SVM)算法（下）_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>     1.1 训练好的模型的算法复杂度是由支持向量的个数决定的，而不是由数据的维度决定的。所以SVM不太容易产生overfitting</div><div>     1.2 SVM训练出来的模型完全依赖于支持向量(Support Vectors), 即使训练集里面所有非支持向量的点都被去除，重复训练过程，结果仍然会得到完全一样的模型。</div><div>     1.3 一个SVM如果训练得出的支持向量个数比较小，SVM训练出的模型比较容易被泛化。</div><div><br/></div><div><br/></div><div>2. 线性不可分的情况 （linearly inseparable case)</div><div><br/></div><div><img src="5.2 支持向量机(SVM)算法（下）_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div>     2.1 数据集在空间中对应的向量不可被一个超平面区分开</div><div><br/></div><div>     2.2 两个步骤来解决：</div><div>          2.2.1 利用一个非线性的映射把原数据集中的向量点转化到一个更高维度的空间中</div><div>          2.2.2 在这个高维度的空间中找一个线性的超平面来根据线性可分的情况处理</div><div><img src="5.2 支持向量机(SVM)算法（下）_files/main-qimg-de8f2ca9c807ee184e2509639fce066d.jpg" type="image/jpeg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/><br/></div><div>          </div><div>               <img src="5.2 支持向量机(SVM)算法（下）_files/main-qimg-dff9507297a2320460ff4d9cd5825683.png" type="image/png" style="cursor: default;cursor: default;"/></div><div><img src="5.2 支持向量机(SVM)算法（下）_files/main-qimg-b88037063b9a4cae241ee6b0ab841356.png" type="image/png" style="cursor: default;cursor: default;"/><br/></div><div>               </div><div><br/></div><div>          </div><div>          2.2.3 视觉化演示 <a href="https://www.youtube.com/watch?v=3liCbRZPrZA">https://www.youtube.com/watch?v=3liCbRZPrZA</a></div><div><br/></div><div>     </div><div>     2.3 如何利用非线性映射把原始数据转化到高维中？</div><div>          2.3.1 例子：</div><div>                   3维输入向量：<img src="5.2 支持向量机(SVM)算法（下）_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>                   转化到6维空间 Z 中去：<img src="5.2 支持向量机(SVM)算法（下）_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/> </div><div>                                                       <img src="5.2 支持向量机(SVM)算法（下）_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div>                   新的决策超平面：<img src="5.2 支持向量机(SVM)算法（下）_files/Image [5].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/>  其中W和Z是向量，这个超平面是线性的</div><div>                   解出W和b之后，并且带入回原方程：</div><div><br/></div><div>                    <img src="5.2 支持向量机(SVM)算法（下）_files/Image [6].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div>          2.3.2 思考问题：</div><div>                    2.3.2.1: 如何选择合理的非线性转化把数据转到高纬度中？</div><div>                    2.3.2.2： 如何解决计算内积时算法复杂度非常高的问题？</div><div><br/></div><div>          2.3.3 使用核方法（kernel trick)</div><div><br/></div><div>3. 核方法（kernel trick)</div><div>     3.1 动机</div><div>          在线性SVM中转化为最优化问题时求解的公式计算都是以内积(dot product)的形式出现的</div><div>          <img src="5.2 支持向量机(SVM)算法（下）_files/Image [7].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/>，其中 <img src="5.2 支持向量机(SVM)算法（下）_files/Image [8].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/> 是把训练集中的向量点转化到高维的非线性映射函数，因为内积的算法复杂          </div><div>          度非常大，所以我们利用核函数来取代计算非线性映射函数的内积</div><div><br/></div><div>     3.1  以下核函数和非线性映射函数的内积等同</div><div>          <img src="5.2 支持向量机(SVM)算法（下）_files/Image [9].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div>     3.2  常用的核函数(kernel functions)</div><div>           </div><div>          h度多项式核函数(polynomial kernel of degree h)：            <img src="5.2 支持向量机(SVM)算法（下）_files/Image [10].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>          高斯径向基核函数(Gaussian radial basis function kernel):  <img src="5.2 支持向量机(SVM)算法（下）_files/Image [11].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>          S型核函数(Sigmoid function kernel):                               <img src="5.2 支持向量机(SVM)算法（下）_files/Image [12].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div>          如何选择使用哪个kernel？</div><div>          根据先验知识，比如图像分类，通常使用RBF，文字不使用RBF</div><div>          尝试不同的kernel，根据结果准确度而定</div><div><br/></div><div>     3.3  核函数举例:</div><div>            假设定义两个向量：<span style="color: rgb(51, 51, 51); line-height: 21px;"> </span><span style="color: rgb(51, 51, 51); line-height: 21px;">x = (x1, x2, x3); y = (y1, y2, y3)</span></div><div>            定义方程：<span style="color: rgb(51, 51, 51); line-height: 21px;">f(x) = (x1x1, x1x2, x1x3, x2x1, x2x2, x2x</span><span style="color: rgb(51, 51, 51); line-height: 21px;">3, x3x1, x3x2, x3x3)</span></div><div><span style="color: rgb(51, 51, 51); line-height: 21px;"><br/></span></div><div><span style="color: rgb(51, 51, 51); line-height: 21px;">            </span><span style="color: rgb(51, 51, 51); line-height: 21px;">K(x, y ) = (&lt;x, y&gt;)^2</span></div><div><span style="color: rgb(51, 51, 51); line-height: 21px;"><br/></span></div><div><span style="color: rgb(51, 51, 51); line-height: 21px;">            假设</span><span style="color: rgb(51, 51, 51); line-height: 21px;">x = (1, 2, 3); y = (4, 5, 6). </span></div><div><span style="color: rgb(51, 51, 51); line-height: 21px;">         </span></div><span style="color: rgb(51, 51, 51); line-height: 21px;">            f(x) = (1, 2, 3, 2, 4, 6, 3, 6, 9)</span><br style="line-height: 21px; color: rgb(51, 51, 51);"/><span style="color: rgb(51, 51, 51); line-height: 21px;">            f(y) = (16, 20, 24, 20, 25, 36, 24, 30, 36)</span><br style="line-height: 21px; color: rgb(51, 51, 51);"/><span style="color: rgb(51, 51, 51); line-height: 21px;">            &lt;f(x), f(y)&gt; = 16 + 40 + 72 + 40 + 100+ 180 + 72 + 180 + 324 = 1024</span><div><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><div><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><div><font color="#333333"><span style="line-height: 21px;">          </span></font> <span style="color: rgb(51, 51, 51); line-height: 21px;">K(x, y) = (4  + 10 + 18 ) ^2 = 32^2 = 1024</span></div><div><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><div><font color="#333333"><span style="line-height: 21px;">           同样的结果，使用kernel方法计算容易很多</span></font></div><div><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><div><font color="#333333"><span style="line-height: 21px;">4. SVM扩展可解决多个类别分类问题</span></font></div><div><font color="#333333"><span style="line-height: 21px;">          对于每个类，有一个当前类和其他类的二类分类器（one-vs-rest)</span></font></div><div><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><div><font color="#333333"><span style="line-height: 21px;">          <br/></span></font><div><span style="color: rgb(51, 51, 51); line-height: 21px;">            </span></div><div>          </div><div>     </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>               </div><div>                                        </div><div>     </div><div><br/></div><div>     </div></div></div>
</div></body></html> 